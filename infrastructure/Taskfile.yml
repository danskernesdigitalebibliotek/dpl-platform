# DPL Platform Infrastructure automation
#
# Provisions and configures Azure infrastructure and support software that is
# required by the DPL Platform.
version: '3'

# Pull in defaults that are used across the tasks.
dotenv:
  - "task/defaults.env"
  - "{{.instance_vars_file}}"

# Any task that uses these variables must have a dependency on the _req_env
# task.
vars:
  # The current environment.
  platform_env: "{{.DPLPLAT_ENV}}"
  # The root directory for the environment.
  dir_env: "environments/{{.platform_env}}"
  # Root of the Terraform-configuration for the environment.
  dir_infra: "environments/{{.platform_env}}/infrastructure"
  # Root of the Terraform-configuration for the github organization.
  dir_env_repos: "environments/{{.platform_env}}/env_repos"
  # Root of the configurations for the environment.
  dir_configuration: "environments/{{.platform_env}}/configuration"
  # Root of the lagoon-configurations for the environment.
  dir_lagoon: "environments/{{.platform_env}}/lagoon"
  # The suffix domain we will use when constructing urls
  global_environment_suffix: "dpl.reload.dk"
  # A file we can write environment variables in we want to persist for this
  # instance of the shell.
  instance_vars_file: "/tmp/instance-vars.env"
  # the name of the plan "webmaster"
  webmaster_plan_name: webmaster
  # the branch used for production environments
  production_branch: main
  # the branch used for moduletest environments
  moduletest_branch: moduletest


tasks:
    default:
      silent: true
      cmds:
        - task -l

    # Internal task for initializing Terraform.
    _infra:terraform:init:
      deps:
        - _req_env
      dir: "{{.dir_infra}}"
      sources:
        - "*.tf"
      generates:
        - ".terraform.lock.hcl"
      cmds:
        - terraform init -upgrade

    infra:terraform:init-upgrade:
      desc: Init and upgrade local Terraform state
      summary: |
        Use this task when the local state needs to be updated. This happens eg.
        when terraform is upgraded.
      deps:
        - _req_env
      dir: "{{.dir_infra}}"
      cmds:
        - terraform init -upgrade

    infra:terraform:output:
      deps: [_req_env, _infra:terraform:init]
      cmds:
        - terraform -chdir={{.dir_infra}} output -json

    infra:provision:
      deps: [_req_env, _infra:terraform:init]
      desc: Provision infrastructure for an environment
      summary: |
        Use Terraform to provision the infrastructure for an environment.
      dir: "{{.dir_infra}}"
      cmds:
        - terraform apply

    infra:keyvault:secret:set:
      deps: [_req_env, _infra:terraform:init]
      desc: Sets a keyvault secret
      cmds:
        # Don't print secrets
        - silent: true
          cmd: az keyvault secret set
              --subscription "{{.AZURE_SUBSCRIPTION_ID}}"
              --name "{{.SECRET_KEY}}"
              --vault-name
                $(
                  terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)"
                )
              --value "{{.SECRET_VALUE}}"
              --query id -o tsv

      preconditions:
      - sh: '[ ! -z "{{.SECRET_KEY}}" ]'
        msg: "Env variable SECRET_KEY is not set or empty."
      - sh: '[ ! -z "{{.SECRET_VALUE}}" ]'
        msg: "Env variable SECRET_VALUE is not set or empty."

    _env_repos:terraform:init:
      dir: "{{.dir_env_repos}}"
      cmds:
        - terraform init

    env_repos:provision:
      deps: [_req_env, _env_repos:terraform:init]
      desc: Provision infrastructure for an environment
      summary: |
        Use Terraform to provision the repositories for our environments.
      env:
        GITHUB_TOKEN:
          sh: az keyvault secret show
              --subscription "{{.AZURE_SUBSCRIPTION_ID}}"
              --name github-infra-admin-pat
              --vault-name
                $(
                  terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)"
                )
              --query value -o tsv
      cmds:
        - cmd: terraform -chdir={{.dir_env_repos}} apply {{.OPTIONS}}


    terraform:import:
      deps: [_req_env, _env_repos:terraform:init]
      desc: Provision infrastructure for an environment
      summary: |
        Import existing ressources into terraform state
      env:
        GITHUB_TOKEN:
          sh: az keyvault secret show
              --subscription "{{.AZURE_SUBSCRIPTION_ID}}"
              --name github-infra-admin-pat
              --vault-name
                $(
                  terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)"
                )
              --query value -o tsv
      cmds:
        - cmd: terraform -chdir={{.dir_env_repos}} import '{{.OPTIONS}}' '{{.ADDRESS_ID}}'

    terraform:import:repo:
      desc: Imports a Github repository for a site by passing the site name
      cmds:
        - task: terraform:import
          vars:
            OPTIONS: module.env_repos.github_repository.site["{{.SITE}}"]
            ADDRESS_ID: env-{{.SITE}}
      preconditions:
      - *require_site

    cluster:auth:
        deps: [_req_env, _infra:terraform:init]
        desc: "Authenticate against AKS and setup a functional kubecontext."
        status:
          - "[ $(kubectl config current-context) == '{{.CLUSTER_NAME}}' ] || exit 1"
        # We normally handle variables via dynamic task variables, but as terraform.
        # Variables are interpolated before dependencies are resolved, so
        # in cases where Terraform is not initialized, this task will break.
        # A lot of other tasks are in the exact same situations.
        # So, to mitigate this, we instead export the variables we need as
        # commands.
        # We sneakily rely on the fact that most procedures starts off with a
        # cluster:auth, which means most people will have their terraform workspace
        # initialized before the run the next task which can then extract variables
        # the "normal" way.
        cmds:
          -
            export CLUSTER_NAME=$(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".cluster_name.value | select (.!=null)") &&
            export RESOURCEGROUP_NAME=$(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".resourcegroup_name.value | select (.!=null)") &&
            az aks get-credentials --only-show-errors --subscription {{.AZURE_SUBSCRIPTION_ID}} --resource-group $RESOURCEGROUP_NAME --name $CLUSTER_NAME &&
            echo "CLUSTER_NAME=$CLUSTER_NAME" >> {{.instance_vars_file}}
        preconditions:
          - sh: "[ ! -z {{.AZURE_SUBSCRIPTION_ID}} ]"
            msg: "Env variable AZURE_SUBSCRIPTION_ID is not set or empty."

    cluster:get-upgrades:
        deps: [_req_env]
        desc: "Get available upgrades for the cluster."
        vars:
          CLUSTER_NAME:
            sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".cluster_name.value | select (.!=null)"
          RESOURCEGROUP_NAME:
            sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".resourcegroup_name.value | select (.!=null)"
        cmds:
          - az aks get-upgrades
              --subscription {{.AZURE_SUBSCRIPTION_ID}}
              --resource-group {{.RESOURCEGROUP_NAME}}
              --name {{.CLUSTER_NAME}}
              --output table
        preconditions:
          - sh: "[ ! -z {{.AZURE_SUBSCRIPTION_ID}} ]"
            msg: "Env variable AZURE_SUBSCRIPTION_ID is not set or empty."

    support:provision:cert-manager:
      deps: [cluster:auth]
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      desc: Install and configure cert-manager
      env:
        ZEROSSL_EAB_SECRET_KEY_ID:
          sh: az keyvault secret show
              --subscription "{{.AZURE_SUBSCRIPTION_ID}}"
              --name zerossl-eabsecret-kid
              --vault-name
                $(
                  terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)"
                )
              --query value -o tsv
        ZEROSSL_EAB_SECRET:
          sh: az keyvault secret show
              --subscription "{{.AZURE_SUBSCRIPTION_ID}}"
              --name zerossl-eabsecret
              --vault-name
                $(
                  terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)"
                )
              --query value -o tsv
      cmds:
        - task/scripts/provision-cert-manager.sh

    support:verify:cert-manager:
      deps: [cluster:auth]
      summary: Verify cert-manager
      desc: Attempts to verify that cert-manager is installed and configured correctly.
      cmds:
        - cm-verifier
        - kubectl get pods --namespace cert-manager

    support:provision:ingress-nginx:
      deps: [cluster:auth]
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      desc: Install and configure ingress-nginx
      env:
        INGRESS_IP:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".ingress_ip.value | select (.!=null)"
        RESOURCE_GROUP:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".resourcegroup_name.value | select (.!=null)"
      cmds:
        - task/scripts/provision-ingress-nginx.sh

    support:provision:minio:
      deps: [cluster:auth]
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      desc: Install and configure two minio gateways for backups and lagoon files
      vars:
        INGRESS_CLASS: nginx
        API_HOSTNAME: files.lagoon.{{.platform_env}}.{{.global_environment_suffix}}
        LAGOON_FILES_CLIENT_ACCESS_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_files_blob_storage_client_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        LAGOON_FILES_CLIENT_SECRET_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_files_blob_storage_client_secret_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        LAGOON_FILES_STORAGE_ACCOUNT_NAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_files_storage_account_name.value | select (.!=null)"
        LAGOON_FILES_STORAGE_ACCOUNT_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_files_primary_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        BAAS_STORAGE_CLIENT_ACCESS_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".backup_blob_storage_client_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        BAAS_STORAGE_CLIENT_SECRET_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".backup_blob_storage_client_secret_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        BAAS_STORAGE_ACCOUNT_NAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".backup_storage_account_name.value | select (.!=null)"
        BAAS_STORAGE_ACCOUNT_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".backup_primary_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
      cmds:
        # We're doing this twice, so we use a separate task for invoking the
        # installation script.

        # Install lagoon files.
        - task: _support:provision:minio:install
          vars:
            HOSTNAME_PREFIX: "files"
            HELM_RELEASE_NAME: "minio-lagoon-files"
            CLIENT_ACCESS_KEY: "{{.LAGOON_FILES_CLIENT_ACCESS_KEY}}"
            CLIENT_SECRET_KEY: "{{.LAGOON_FILES_CLIENT_SECRET_KEY}}"
            STORAGE_ACCOUNT_NAME: "{{.LAGOON_FILES_STORAGE_ACCOUNT_NAME}}"
            STORAGE_ACCOUNT_KEY: "{{.LAGOON_FILES_STORAGE_ACCOUNT_KEY}}"
        - task: _support:provision:minio:install
          vars:
            HOSTNAME_PREFIX: "backup-storage"
            HELM_RELEASE_NAME: "minio-backup"
            CLIENT_ACCESS_KEY: "{{.BAAS_STORAGE_CLIENT_ACCESS_KEY}}"
            CLIENT_SECRET_KEY: "{{.BAAS_STORAGE_CLIENT_SECRET_KEY}}"
            STORAGE_ACCOUNT_NAME: "{{.BAAS_STORAGE_ACCOUNT_NAME}}"
            STORAGE_ACCOUNT_KEY: "{{.BAAS_STORAGE_ACCOUNT_KEY}}"

    _support:provision:minio:install:
      summary: Do one of the two minio installations.
      env:
        INGRESS_CLASS: nginx
        HELM_RELEASE_NAME: "{{.HELM_RELEASE_NAME}}"
        API_HOSTNAME: "{{.HOSTNAME_PREFIX}}.lagoon.{{.platform_env}}.{{.global_environment_suffix}}"
        # Copy the task variables we've been passed into environment variables
        # that the script can read.
        CLIENT_ACCESS_KEY: "{{.CLIENT_ACCESS_KEY}}"
        CLIENT_SECRET_KEY: "{{.CLIENT_SECRET_KEY}}"
        STORAGE_ACCOUNT_NAME: "{{.STORAGE_ACCOUNT_NAME}}"
        STORAGE_ACCOUNT_KEY: "{{.STORAGE_ACCOUNT_KEY}}"
      cmds:
        - task/scripts/provision-minio.sh

    support:provision:k8up:
      deps: [cluster:auth]
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      desc: Install and configure the K8up backup operator
      env:
        # Specify the two endpoints k8up will use for backup and restore.
        # We specify a cluster service for backups to keep performance as
        # good as possible.
        BACKUP_API_URL: http://minio-backup.minio.svc.cluster.local:9000
        # And the same endpoint now behind an Ingress as we need it to be
        # available from a browser.
        RESTORE_API_URL: https://backup-storage.lagoon.{{.platform_env}}.{{.global_environment_suffix}}
        # As specified in the values file for lagoon-core
        LAGOON_BACKUP_HANDLER_URL: https://backuphandler.lagoon.{{.platform_env}}.{{.global_environment_suffix}}
        K8UP_GLOBALSTATSURL: https://k8up.lagoon.{{.platform_env}}.{{.global_environment_suffix}}
        BACKUP_CLIENT_ACCESS_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".backup_blob_storage_client_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        BACKUP_CLIENT_SECRET_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".backup_blob_storage_client_secret_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        RESTORE_CLIENT_ACCESS_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".backup_blob_storage_client_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        RESTORE_CLIENT_SECRET_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".backup_blob_storage_client_secret_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
      cmds:
        - task/scripts/provision-k8up.sh

    lagoon:provision:core:
      deps: [cluster:auth]
      desc: Install and configure Lagoon core
      vars:
        # If DIFF is set, use the diff helm plugin
        DIFF_COMMAND: '{{empty .DIFF | ternary "" "diff"}}'
      env:
        # Collect the values we'll render into the values-file for the chart.
        KEYCLOAK_ADMIN_PASS:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keycloak_admin_pass_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        HARBOR_ADMIN_PASS:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".harbor_admin_pass_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        LAGOON_FILES_API_URL: https://files.lagoon.{{.platform_env}}.{{.global_environment_suffix}}
        LAGOON_FILES_HOSTNAME:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_files_blob_storage_client_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        LAGOON_FILES_ACCESS_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_files_blob_storage_client_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        LAGOON_FILES_SECRET_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_files_blob_storage_client_secret_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        LAGOON_FILES_BUCKET:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_files_blob_storage_container_name.value | select (.!=null)"
        BAAS_STORAGE_ACCESS_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".backup_blob_storage_client_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        BAAS_STORAGE_SECRET_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".backup_blob_storage_client_secret_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        CHART_VERSION_LAGOON_CORE:
          sh: source "{{.dir_lagoon}}/lagoon-versions.env" && echo $VERSION_LAGOON_CORE
      cmds:
        - |
          envsubst '$HARBOR_ADMIN_PASS $KEYCLOAK_ADMIN_PASS $LAGOON_FILES_API_URL $LAGOON_FILES_ACCESS_KEY $LAGOON_FILES_BUCKET $LAGOON_FILES_SECRET_KEY $BAAS_STORAGE_ACCESS_KEY $BAAS_STORAGE_SECRET_KEY' \
          < "{{.dir_lagoon}}/lagoon-core-values.template.yaml" \
          > "{{.dir_lagoon}}/lagoon-core-values.yaml"
        # Setup the namespace manually to control eg. labels on the namespace.
        - kubectl apply -f {{.dir_lagoon}}/lagoon-core-namespace.yaml
        - helm repo add lagoon https://uselagoon.github.io/lagoon-charts/
        - |
          helm {{.DIFF_COMMAND}} upgrade \
          --install \
          --namespace lagoon-core \
          -f {{.dir_lagoon}}/lagoon-core-values.yaml \
          --version $CHART_VERSION_LAGOON_CORE \
          lagoon-core \
          lagoon/lagoon-core
      preconditions:
      - sh: "[ ! -z ${KEYCLOAK_ADMIN_PASS} ]"
        msg: "Could not extract the password for the keycloak admin from keyvault."
      - sh: "[ ! -z ${HARBOR_ADMIN_PASS} ]"
        msg: "Could not extract the password for the harbor admin from keyvault."

    lagoon:provision:core-db-migration:
      deps: [cluster:auth]
      desc: Run database migrations after an upgrade
      cmds:
        - kubectl --namespace lagoon-core exec -it lagoon-core-api-db-0 -- sh -c /rerun_initdb.sh

    lagoon:cli:config:
      deps: [cluster:auth]
      desc: Configure a lagoon cli with the knowledge of a lagoon core.
      summary: |
        In order for the cli to auth your public ssh-key must have been added to
        the core and must be available to ssh eg via "eval $(ssh-agent); ssh-add"
      vars:
        ssh_loadbalancer_ip:
          sh: task cluster:auth && kubectl get -o jsonpath='{.status.loadBalancer.ingress[0].ip}' -n lagoon-core service lagoon-core-ssh
      status:
        - test -f {{.HOME}}/.lagoon.yml

      cmds:
        - |
            lagoon config add \
            --graphql https://api.lagoon.{{.platform_env}}.{{.global_environment_suffix}}/graphql \
            --force \
            --ui https://ui.lagoon.{{.platform_env}}.{{.global_environment_suffix}} \
            --hostname {{.ssh_loadbalancer_ip}} \
            --port 22 \
            --lagoon {{.platform_env}}
        - lagoon config default --lagoon {{.platform_env}}
        - lagoon login
        - lagoon whoami
      preconditions:
      - sh: "[ ! -z {{.ssh_loadbalancer_ip}} ]"
        msg: "Could not determine IP of the ssh-endpoint for Lagoon. The Kubernetes lagoon-core/lagoon-core-ssh service may not have been provisioned yet."

    support:provision:harbor:
      deps: [cluster:auth]
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      desc: Install an instance of Harbor into a Lagoon cluster.

      vars:
        # If DIFF is set, use the diff helm plugin
        DIFF_COMMAND: '{{empty .DIFF | ternary "" "diff"}}'

      env:
        HARBOR_HOSTNAME: harbor.lagoon.{{.platform_env}}.{{.global_environment_suffix}}
        HARBOR_EXTERNAL_URL: https://harbor.lagoon.{{.platform_env}}.{{.global_environment_suffix}}
        HARBOR_ADMIN_PASS:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".harbor_admin_pass_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        STORAGE_ACCOUNT_NAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".harbor_storage_account_name.value | select (.!=null)"
        STORAGE_ACCOUNT_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".harbor_primary_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        STORAGE_CONTAINER_NAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".harbor_blob_storage_container_name.value | select (.!=null)"

      cmds:
        - task/scripts/provision-harbor.sh

      preconditions:
      - sh: "[ ! -z ${HARBOR_ADMIN_PASS} ]"
        msg: "Could not extract the password for the Harbor admin from keyvault."

    lagoon:provision:remote:
      deps: [cluster:auth]
      desc: Install and configure Lagoon remote
      vars:
        # If DIFF is set, use the diff helm plugin
        DIFF_COMMAND: '{{empty .DIFF | ternary "" "diff"}}'
      env:
        # Fetch a number of variables we'll need to add to a values-file.
        SSH_LOADBALANCER_IP:
          sh: task cluster:auth && kubectl get -o jsonpath='{.status.loadBalancer.ingress[0].ip}' -n lagoon-core service lagoon-core-ssh
        RABBITMQ_PASS:
          sh: task cluster:auth && kubectl -n lagoon-core get secret lagoon-core-broker -o jsonpath="{.data.RABBITMQ_PASSWORD}" | base64 -d
        HARBOR_ADMIN_PASS:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".harbor_admin_pass_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        SQL_HOSTNAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".sql_hostname.value | select (.!=null)"
        SQL_SERVERNAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".sql_servername.value | select (.!=null)"
        SQL_USER:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".sql_user.value | select (.!=null)"
        SQL_PASSWORD:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".sql_password_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        CHART_VERSION_LAGOON_REMOTE:
          sh: source "{{.dir_lagoon}}/lagoon-versions.env" && echo $VERSION_LAGOON_REMOTE
        BUILD_DEPLOY_DIND_IMAGE_VER:
          sh: source "{{.dir_lagoon}}/lagoon-versions.env" && echo $BUILD_DEPLOY_DIND_IMAGE_VER
        ACS_CONNECTION_STRING:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".acs_connection_string.value | select (.!=null)"
      cmds:
        # Render the variables we've collected into a values file we can install.
        - |
          envsubst '$SSH_LOADBALANCER_IP $RABBITMQ_PASS $HARBOR_ADMIN_PASS $SQL_HOSTNAME $SQL_SERVERNAME $SQL_USER $SQL_PASSWORD $BUILD_DEPLOY_DIND_IMAGE_VER $ACS_CONNECTION_STRING' \
          < "{{.dir_lagoon}}/lagoon-remote-values.template.yaml" \
          > "{{.dir_lagoon}}/lagoon-remote-values.yaml"
        # Setup the namespace manually to control eg. labels on the namespace.
        - kubectl apply -f {{.dir_lagoon}}/lagoon-remote-namespace.yaml
        # Add the lagoon helm repo and install or upgrade the chart.
        - helm repo add lagoon https://uselagoon.github.io/lagoon-charts/
        - |
          helm {{.DIFF_COMMAND}} \
            upgrade --install \--namespace lagoon \
            -f {{.dir_lagoon}}/lagoon-remote-values.yaml \
            --version $CHART_VERSION_LAGOON_REMOTE \
            lagoon-remote \
            lagoon/lagoon-remote
      preconditions:
      - sh: "[ ! -z ${RABBITMQ_PASS} ]"
        msg: "Could not extract the password for the rabbitmq admin from Kubernetes."
      - sh: "[ ! -z ${SSH_LOADBALANCER_IP} ]"
        msg: "Could not determine IP of the load balancer. The lagoon-core/lagoon-core-ssh service may not have been provisioned yet."
      - sh: "[ ! -z ${HARBOR_ADMIN_PASS} ]"
        msg: "Could not extract the password for the Harbor admin from keyvault."

    lagoon:run-mutation:
      deps: [lagoon:cli:config]
      desc: Executes a specified mutation against the Lagoon GraphQL API
      vars:
        # Collect the values we'll need for a graphql invocation.
        lagoon_hostname_api:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_hostname_api.value | select (.!=null)"
        cluster_api_url:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".cluster_api_url.value | select (.!=null)"
        lagoon_domain_base:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_domain_base.value | select (.!=null)"
        user_token:
          sh: lagoon login > /dev/null && yq eval ".lagoons.{{.platform_env}}.token" - < ~/.lagoon.yml
        VARIABLES_JSON:
          sh: |
            if [ ! -z "{{.VARIABLES}}" ]; then
              echo -n ",\"variables\":{{.VARIABLES | default "" | replace "\n" ""}}"
            fi
      # Send the mutation request against graphql, using the bearer token passed
      # by the user.
      cmds:
        - |
          curl \
            -H 'Content-Type: application/json' \
            -H "Authorization: Bearer {{.user_token}}" \
            -d '{"query":"{{.MUTATION | replace "\n" ""}}"{{.VARIABLES_JSON}} }' \
            https://{{.lagoon_hostname_api}}/graphql
      preconditions:
      - sh: "[ ! -z {{.lagoon_hostname_api}} ]"
        msg: "Could not determine the api hostname for Lagoon from Kubernetes"
      - sh: "[ ! -z {{.cluster_api_url}} ]"
        msg: "Could not determine the hostname for the Kubernetes API"
      - sh: "[ ! -z {{.lagoon_domain_base}} ]"
        msg: "Could not determine the Lagoon base domain"
      - sh: "[ ! -z '{{.MUTATION}}' ]"
        msg: "Missing mutation to execute"

    lagoon:delete-user-by-id:
      desc: Deletes a user with a given ID
      cmds:
        - task: lagoon:run-mutation
          vars:
            MUTATION: |
              mutation deleteUser($id: String!) { deleteUser(input: {user: {id: $id}}) }
            VARIABLES: |
              {"id":"{{.ID}}"}
      preconditions:
      - sh: "[ ! -z '{{.ID}}' ]"
        msg: "Missing ID of user to delete"

    lagoon:set:environment-variable:
      desc: Sets an environment variable on a lagoon site. This task automates the instructions from https://docs.lagoon.sh/lagoon/using-lagoon-advanced/environment-variables
      cmds:
        - task: lagoon:run-mutation
          vars:
            MUTATION: |
              mutation addEnvironmentVariable {
                addEnvVariable(
                  input:{
                    type:{{.VARIABLE_TYPE}},
                    typeId:{{.VARIABLE_TYPE_ID}},
                    scope:{{.VARIABLE_SCOPE}},
                    name:\"{{.VARIABLE_NAME}}\",
                    value:\"{{.VARIABLE_VALUE}}\"
                  }
                ) {
                  id
                }
              }
      preconditions:
      - sh: "[ ! -z {{.VARIABLE_VALUE}} ]"
        msg: "Missing VARIABLE_VALUE"
      - sh: "[ ! -z {{.VARIABLE_TYPE_ID}} ]"
        msg: "Missing VARIABLE_TYPE_ID"
      - sh: "[ ! -z {{.VARIABLE_NAME}} ]"
        msg: "Missing VARIABLE_NAME"
      - sh: "[ ! -z {{.VARIABLE_SCOPE}} ]"
        msg: "Missing VARIABLE_SCOPE"
      - sh: "[ ! -z {{.VARIABLE_TYPE}} ]"
        msg: "Missing VARIABLE_TYPE"

    lagoon:ensure:environment-variable:
      desc: |
        Ensures (creates or updates) the state of a particular environment variable.
        Based on this mutation resolver: https://github.com/uselagoon/lagoon/blob/1ef8e57ffbc969a308e9a16bb53929edac562a4d/services/api/src/resources/env-variables/resolvers.ts#L300
      vars:
        ENVIRONMENT_NAME_INPUT:
          sh: |
            if [ ! -z \"{{.ENVIRONMENT_NAME}}\" ]; then
              echo -n "";
            else
              echo -n 'environment: \"{{.ENVIRONMENT_NAME}}\",';
            fi
      cmds:
        - task: lagoon:run-mutation
          vars:
            MUTATION: |
              mutation ensureEnvironmentVariable {
                addOrUpdateEnvVariableByName(
                  input:{
                    project:\"{{.PROJECT_NAME}}\",{{.ENVIRONMENT_NAME_INPUT}}
                    scope:{{.VARIABLE_SCOPE}},
                    name:\"{{.VARIABLE_NAME}}\",
                    value:\"{{.VARIABLE_VALUE}}\"
                  }
                ) {
                  id
                }
              }
      preconditions:
      - sh: "[ ! -z {{.VARIABLE_VALUE}} ]"
        msg: "Missing VARIABLE_VALUE"
      - sh: "[ ! -z {{.VARIABLE_NAME}} ]"
        msg: "Missing VARIABLE_NAME"
      - sh: "[ ! -z {{.VARIABLE_SCOPE}} ]"
        msg: "Missing VARIABLE_SCOPE"
      - sh: "[ ! -z {{.PROJECT_NAME}} ]"
        msg: "Missing PROJECT_NAME"

    lagoon:project:ensure:github-registry-credentials:
      vars:
        GITHUB_TOKEN:
          sh: az keyvault secret show
              --subscription "{{.AZURE_SUBSCRIPTION_ID}}"
              --name github-infra-admin-pat
              --vault-name
                $(
                  terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)"
                )
              --query value -o tsv
      cmds:
      - task: lagoon:ensure:environment-variable
        vars:
          VARIABLE_SCOPE: "CONTAINER_REGISTRY"
          VARIABLE_NAME: "GITHUB_REGISTRY_CREDENTIALS"
          VARIABLE_VALUE: "{{.GITHUB_TOKEN}}"
          PROJECT_NAME: "{{.PROJECT_NAME}}"
      preconditions:
      - sh: "[ ! -z \"{{.PROJECT_NAME}}\" ]"
        msg: "Missing PROJECT_ID or PROJECT_NAME - at least one must be set"

    lagoon:project:ensure:azure-mail-connection-string:
      vars:
        ACS_CONNECTION_STRING:
          sh: az communication list-key
              --name communication-servicesa5e3
              --resource-group
                $(
                  terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".resourcegroup_name.value | select (.!=null)"
                )
              --query "primaryConnectionString"
              --output tsv
      cmds:
      - task: lagoon:ensure:environment-variable
        vars:
          VARIABLE_SCOPE: "CONTAINER_REGISTRY"
          VARIABLE_NAME: "AZURE_MAIL_CONNECTION_STRING"
          VARIABLE_VALUE: "{{.ACS_CONNECTION_STRING}}"
          PROJECT_NAME: "{{.PROJECT_NAME}}"
      preconditions:
      - sh: "[ ! -z \"{{.PROJECT_NAME}}\" ]"
        msg: "Missing PROJECT_ID or PROJECT_NAME - at least one must be set"

    lagoon:add:cluster:
      deps: [cluster:auth]
      desc: Add a Kubernetes cluster (Lagoon Remote) to the Lagoon Core.
      summary: |
       You must provide a valid bearer token for a lagoon user via the USER_TOKEN environment variable.
       It can be found under the token property in $HOME/.lagoon.yml after you've done a lagoon login

      vars:
        # Collect the values we'll need for a graphql invocation.
        lagoon_hostname_api:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_hostname_api.value | select (.!=null)"
        cluster_api_url:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".cluster_api_url.value | select (.!=null)"
        lagoon_domain_base:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".lagoon_domain_base.value | select (.!=null)"
        builddeploy_token:
          sh: "kubectl -n lagoon describe secret $(kubectl -n lagoon get secret | grep kubernetes-build-deploy | awk '{print $1}') | grep token: | awk '{print $2}'"

        # Prepare the mutation.
        mutation: |
          {
          "query": "mutation addKubernetes {
              addKubernetes(input:
                {
                  id: 1,
                  name: \"lagoon\",
                  consoleUrl: \"{{.cluster_api_url}}\",
                  token: \"{{.builddeploy_token}}\",
                  routerPattern: \"${environment}.${project}.{{.lagoon_domain_base}}\"
                }
              )
              {id}
            }"
          }

      # Send the mutation request against graphql, using the bearer token passed
      # by the user.
      cmds:
        - |
          curl \
            -H 'Content-Type: application/json' \
            -H "Authorization: Bearer {{.USER_TOKEN}}" \
            -d '{{.mutation | replace "\n" ""}}' \
            https://{{.lagoon_hostname_api}}/graphql

      preconditions:
      - sh: "[ ! -z {{.lagoon_hostname_api}} ]"
        msg: "Could not determine the api hostname for Lagoon from Kubernetes"
      - sh: "[ ! -z {{.cluster_api_url}} ]"
        msg: "Could not determine the hostname for the Kubernetes API"
      - sh: "[ ! -z {{.lagoon_domain_base}} ]"
        msg: "Could not determine the Lagoon base domain"
      - sh: "[ ! -z {{.builddeploy_token}} ]"
        msg: "Could not determine the build-deploy token from Kubernetes"
      - sh: "[ ! -z {{.USER_TOKEN}} ]"
        msg: "Missing USER_TOKEN"

    lagoon:project:set:
      desc: Set a project state in lagoon using a command, either "add" or "update"
      deps: [lagoon:cli:config]
      vars:
        BRANCHES: '{{ .BRANCHES | default "main" }}'
      cmds:
        # - We assume that there will only be a single remote pr core, so we
        #   hardcode --openshift (aka remote) to 1.
        # - We deploy the relevant (default: main) branches
        # - We configure the main branch to be the production environment,
        #   This primarily means that develop will auto-idle
        # - We bump the max allowed dev environments (default is 5)
        - |
            lagoon {{.COMMAND}} project \
            --gitUrl {{.GIT_URL}} \
            --openshift 1 \
            --productionEnvironment {{.production_branch}} \
            --developmentEnvironmentsLimit 25 \
            --branches "^({{ .BRANCHES }})$" \
            --project {{.PROJECT_NAME}}
        - task: lagoon:project:ensure:github-registry-credentials
          vars:
            PROJECT_NAME: "{{.PROJECT_NAME}}"
        - task: lagoon:project:ensure:azure-mail-connection-string
          vars:
            PROJECT_NAME: "{{.PROJECT_NAME}}"
      preconditions:
      - sh: "[ ! -z {{.GIT_URL}} ]"
        msg: "Env variable GIT_URL is not set or empty."
      - sh: "[ ! -z {{.PROJECT_NAME}} ]"
        msg: "Env variable PROJECT_NAME is not set or empty."
      - sh: "[ {{.COMMAND}} = 'add' ] || [ {{.COMMAND}} = 'update' ]"
        msg: "Variable COMMAND must be set to 'add' or 'update'"

    lagoon:project:add:
      desc: Add a project to a lagoon remote
      cmds:
        - task: lagoon:project:set
          vars:
            COMMAND: "add"
            GIT_URL: "{{.GIT_URL}}"
            PROJECT_NAME: "{{.PROJECT_NAME}}"
            BRANCHES: "{{.BRANCHES}}"

    lagoon:project:deploykey:
      desc: Gets the deployment key for a project
      deps: [lagoon:cli:config]
      cmds:
        - lagoon get project-key --project {{.PROJECT_NAME}}
      preconditions:
      - sh: "[ ! -z {{.PROJECT_NAME}} ]"
        msg: "Env variable PROJECT_NAME is not set or empty."

    lagoon:project:update:
      desc: Add a project to a lagoon remote
      cmds:
        - task: lagoon:project:set
          vars:
            COMMAND: "update"
            GIT_URL: "{{.GIT_URL}}"
            PROJECT_NAME: "{{.PROJECT_NAME}}"
            BRANCHES: "{{.BRANCHES}}"

    support:provision:bulk-storage:
      deps: [cluster:auth]
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      desc: Install and configure a bulk storage class
      env:
        STORAGE_ACCOUNT_NAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".storage_account_name.value | select (.!=null)"
        STORAGE_ACCOUNT_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".storage_primary_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        RESOURCE_GROUP:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".resourcegroup_name.value | select (.!=null)"
      cmds:
        - task/scripts/provision-bulk-storage.sh

    support:provision:loki:
      deps: [cluster:auth]
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      desc: Install and configure Loki
      env:
        STORAGE_ACCOUNT_NAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".monitoring_storage_account_name.value | select (.!=null)"
        STORAGE_ACCOUNT_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".monitoring_primary_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        STORAGE_CONTAINER_NAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".monitoring_blob_storage_container_name.value | select (.!=null)"
      cmds:
        - task/scripts/provision-loki.sh

    support:provision:promtail:
      deps: [cluster:auth]
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      desc: Install and configure Promtail
      env:
        STORAGE_ACCOUNT_NAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".monitoring_storage_account_name.value | select (.!=null)"
        STORAGE_ACCOUNT_KEY:
          sh: az keyvault secret show --subscription "{{.AZURE_SUBSCRIPTION_ID}}" --name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".monitoring_primary_access_key_name.value | select (.!=null)") --vault-name $(terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)") --query value -o tsv
        STORAGE_CONTAINER_NAME:
          sh: terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".monitoring_blob_storage_container_name.value | select (.!=null)"
      cmds:
        - task/scripts/provision-promtail.sh

    support:provision:grafana:
      deps: [cluster:auth]
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      desc: Install and configure Grafana
      cmds:
        - task/scripts/provision-grafana.sh

    support:provision:prometheus:
      deps: [cluster:auth]
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      desc: Install and configure Prometheus
      cmds:
        - task/scripts/provision-prometheus.sh

    ops:get-versions:
      deps: [cluster:auth]
      summary: Extract the current and latest version for the things we've installed into the cluster.
      desc: Extract the current and latest versions
      env:
        GET_AVAILABLE_VERSION: 1
      silent: true
      cmds:
        # TODO - get Lagoon version
        # A bit silly we have to invoke Task this way, but it is the only way
        # to pass in an environment variable to another task.
        - echo "Running support:provision in get version mode to retrive versions"
        - task --silent support:provision

    support:provision:
      deps: [cluster:auth]
      desc: Install and configure the support tools Lagoon and DPL Platform builds on
      summary: Set the DIFF environment variable to any value to switch to diffing instead of an actual upgrade.
      dir: "{{.dir_configuration}}"
      vars:
        DIFF_COMMAND: '{{empty .DIFF | ternary "" "diff"}}'
      cmds:
        - task: support:provision:bulk-storage
        - task: support:provision:cert-manager
        - task: support:provision:grafana
        - task: support:provision:harbor
        - task: support:provision:ingress-nginx
        - task: support:provision:k8up
        - task: support:provision:loki
        - task: support:provision:minio
        - task: support:provision:prometheus
        - task: support:provision:promtail

    site:sync:
      desc: Runs the a dpladm sync of a site which eg. can be used to deploy a new release
      summary: Run the task without additional variables to see required arguments
      env:
        SITES_CONFIG: "{{.dir_env}}/sites.yaml"
        SITE: "{{.SITE}}"
        GITHUB_TOKEN:
          sh: az keyvault secret show
              --subscription "{{.AZURE_SUBSCRIPTION_ID}}"
              --name github-infra-admin-pat
              --vault-name
                $(
                  terraform -chdir={{.dir_infra}} output -json | jq --raw-output ".keyvault_name.value | select (.!=null)"
                )
              --query value -o tsv
      cmds:
        - dpladm/bin/sync-site.sh
      preconditions:
      - &require_site {
          sh: "[ ! -z \"{{.SITE}}\" ]",
          msg: "Variable SITE is not set or empty."
        }

    sites:list-keys:
      desc: List keys for sites in sites.yaml config
      dir: "{{.dir_env}}"
      cmds:
        - cat sites.yaml | yq '.sites | keys | .[]'

    sites:check:
      desc: Simply checks that all sites defined in sites.yaml are running and responding
      dir: "{{.dir_env}}"
      vars:
        sites:
          sh: cat {{.dir_env}}/sites.yaml | yq '.sites | keys | .[]'
      cmds:
        - touch statusnow.txt
        - for: { var: sites }
          cmd: |
            if [[ "$(curl -I https://varnish.main.{{.ITEM}}.dplplat01.dpl.reload.dk | head -1)" == "HTTP/2 200"* ]]; then
              echo "{{.ITEM}}: OK" >> statusnow.txt;
            else
              echo "{{.ITEM}}: ERROR! Not up." >> statusnow.txt;
            fi
        - cat statusnow.txt
        - rm statusnow.txt

    sites:sync:
      desc: Performs a full synchronization from sites.yaml to running state
      dir: "{{.dir_env}}"
      vars:
        sites:
          sh: cat {{.dir_env}}/sites.yaml | yq '.sites | keys | .[]'
      cmds:
        - task: env_repos:provision
          vars:
            OPTIONS: "{{.INITIAL_TERRAFORM_OPTIONS}}"
        - for: { var: sites }
          task: site:full-sync
          vars:
            SITE: "{{.ITEM}}"

    site:full-sync:
      desc: Performs a full syncrhonization from sites.yaml for a single site to running state
      dir: "{{.dir_env}}"
      cmds:
        - task: site:lagoon:project:ensure
          vars:
            SITE: "{{.SITE}}"
        - task: site:lagoon:project:capture-deploy-key
          vars:
            SITE: "{{.SITE}}"
        - task: env_repos:provision
          vars:
            OPTIONS: -refresh=false
        - task: site:lagoon:ensure-first-deployment
          vars:
            SITE: "{{.SITE}}"
        - task: site:sync
          vars:
            SITE: "{{.SITE}}"
      preconditions:
      - *require_site

    site:lagoon:project:ensure:
      desc: |
        Ensures a lagoon project is set up and configured correctly for a
        given site as specified by sites.yaml
      deps: [lagoon:cli:config]
      dir: "{{.dir_env}}"
      vars:
        GIT_URL: "git@github.com:danishpubliclibraries/env-{{.SITE}}.git"
        SITE_PLAN:
          sh: cat {{.dir_env}}/sites.yaml | yq ".sites[\"{{.SITE}}\"].plan"
        BRANCHES:
          sh: if [ "{{.SITE_PLAN}}" = "{{.webmaster_plan_name}}" ]; then echo "{{.production_branch}}|{{.moduletest_branch}}"; else echo "{{.production_branch}}"; fi
      cmds:
        - |
          if [ "$(lagoon get project --project "{{.SITE}}" --output-json | jq '.data[0].id' --raw-output)" = "0" ]; then
            PROJECT_NAME="{{.SITE}}" GIT_URL="{{.GIT_URL}}" BRANCHES="{{.BRANCHES}}" task lagoon:project:add;
          else
            PROJECT_NAME="{{.SITE}}" GIT_URL="{{.GIT_URL}}" BRANCHES="{{.BRANCHES}}" task lagoon:project:update;
          fi
      preconditions:
      - *require_site

    site:lagoon:project:capture-deploy-key:
      # TODO: print a big message if a deploy key is newly captured, so we know to commit changes!
      desc: Gets the deploy key for a particular project from Lagoon and persists it in sites.yaml
      deps: [lagoon:cli:config]
      dir: "{{.dir_env}}"
      vars:
        DEPLOY_KEY:
          sh: lagoon get project-key --project "{{.SITE}}" --output-json | jq '.data[0].publickey' --raw-output
        SITE: "{{.SITE}}"
      cmds:
        - yq -i e '.sites["{{.SITE}}"].deploy_key |= "{{.DEPLOY_KEY}}" | (... | select(tag == "!!merge")) tag = ""' sites.yaml
      preconditions:
      - *require_site

    site:lagoon:ensure-first-deployment:
      desc: Ensures that a site has at least one deployment on required branches, so they are tracked by Lagoon
      deps: [lagoon:cli:config]
      dir: "{{.dir_env}}"
      env:
        SITE: "{{.SITE}}"
      cmds:
        - |
          if [ "$(lagoon list deployments --project "{{.SITE}}" --environment {{.production_branch}} --output-json | jq '.data | length')" = "0" ]; then
            lagoon deploy branch --project "{{.SITE}}" --branch "{{.production_branch}}";
          fi
        - |
          if [ "$(yq '.sites[env(SITE)].plan' sites.yaml)" = "{{.webmaster_plan_name}}" -a "$(lagoon list deployments --project "{{.SITE}}" --environment {{.moduletest_branch}} --output-json | jq '.data | length')" = "0" ]; then
            lagoon deploy branch --project "{{.SITE}}" --branch "{{.moduletest_branch}}";
          fi
      preconditions:
      - *require_site

    ui-password:
      deps: [cluster:auth]
      desc: Get the password to access a given user interface
      cmds:
      - task/scripts/ui-password.sh
      preconditions:
      - sh: "[ ! -z {{.UI_NAME}} ]"
        msg: "Env variable UI_NAME is not set or empty."

    _req_env:
      preconditions:
      - sh: "[ ! -z {{.DPLPLAT_ENV}} ]"
        msg: "Env variable DPLPLAT_ENV is not set or empty."
      - sh: "[ -d {{.dir_env}} ]"
        msg: "Could not find directory {{.dir_env}}"
      - sh: "[ -d {{.dir_infra}} ]"
        msg: "Could not find directory {{.dir_infra}}"
      - sh: "[ -d {{.dir_configuration}} ]"
        msg: "Could not find directory {{.dir_configuration}}"
